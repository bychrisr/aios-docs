---
title: "Prd Cli Graph Dashboard"
---

# CLI Graph Dashboard â€” Product Requirements Document (PRD)

## Goals and Background Context

### Goals

- Fornecer visualizaÃ§Ã£o interativa do dependency graph do code-intel no terminal
- Permitir inspeÃ§Ã£o de blast radius, entity relationships e mÃ©tricas de cache/latency via CLI
- Manter alinhamento com Artigo I da Constitution (CLI First) â€” zero dependÃªncia de UI web
- Tornar dados internos do code-intel visÃ­veis ao usuÃ¡rio (hoje fluem apenas internamente para agentes)
- Suportar mÃºltiplos formatos de output (ASCII, DOT, Mermaid, JSON) para integraÃ§Ã£o com ferramentas externas

### Background Context

O Epic NOGIC (Code Intelligence) construiu um mÃ³dulo completo de inteligÃªncia de cÃ³digo com 8 capabilities primitivas, 5 compostas e 6 helpers por agente â€” totalizando 275 testes passando. Contudo, toda essa inteligÃªncia Ã© consumida internamente pelos agentes e **nÃ£o hÃ¡ nenhuma forma de visualizar os grafos, mÃ©tricas ou relacionamentos no terminal**. Os dados existem (dependency graph, blast radius, entity stats, cache metrics, latency) mas sÃ£o invisÃ­veis ao usuÃ¡rio.

Este PRD define um CLI Graph Dashboard que expÃµe essa riqueza de dados de forma interativa no terminal, usando bibliotecas TUI maduras como `blessed-contrib` para widgets ricos (tree, sparkline, charts, gauges).

### Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-21 | 1.0 | Initial PRD draft baseado em deep research | Morgan (@pm) |

---

## Requirements

### Functional

- **FR1:** O sistema deve renderizar o dependency graph como uma Ã¡rvore interativa com expand/collapse no terminal (`analyzeDependencies` â†’ tree widget)
- **FR2:** O sistema deve exibir blast radius visual para qualquer arquivo selecionado (`assessImpact` â†’ gauge/risk display)
- **FR3:** O sistema deve mostrar mÃ©tricas de cache (hits/misses) como sparklines em tempo real (`client.getMetrics()` â†’ sparkline widget)
- **FR4:** O sistema deve plotar latency das capabilities como line chart (`client._latencyLog` â†’ line chart)
- **FR5:** O sistema deve exibir estatÃ­sticas de entidades do entity-registry (total, categorias, Ãºltima atualizaÃ§Ã£o) como tabela (`registry-loader` â†’ table widget)
- **FR6:** O sistema deve mostrar status do provider code-intel (ativo/inativo, circuit breaker state, failures, uptime) (`isCodeIntelAvailable` + CB â†’ status widget)
- **FR7:** O sistema deve suportar output em mÃºltiplos formatos: ASCII (padrÃ£o), DOT (Graphviz), Mermaid (docs), JSON (processamento programÃ¡tico)
- **FR8:** O sistema deve suportar modo `--watch` para atualizaÃ§Ã£o em tempo real do dashboard
- **FR9:** O sistema deve funcionar como CLI command (`aios graph`) com sub-comandos: `--deps`, `--blast &lt;file&gt;`, `--stats`, `--watch`
- **FR10:** O sistema deve fornecer fallback para dados estÃ¡ticos do entity-registry quando o Code Graph MCP estiver offline

### Non Functional

- **NFR1:** O dashboard deve iniciar em menos de 2 segundos
- **NFR2:** Updates em modo `--watch` devem ocorrer a cada 5 segundos sem impacto perceptÃ­vel de performance
- **NFR3:** O sistema deve funcionar em Windows Terminal, PowerShell, e terminais Unix (bash/zsh) â€” cross-platform
- **NFR4:** O sistema deve funcionar over SSH sem degradaÃ§Ã£o significativa
- **NFR5:** DependÃªncias novas devem ser mÃ­nimas e mantidas ativamente (blessed/neo-blessed, blessed-contrib, asciichart)
- **NFR6:** O sistema deve degradar graciosamente se o terminal nÃ£o suportar Unicode box-drawing characters

---

## Technical Assumptions

### Repository Structure: Monorepo

O CLI Graph Dashboard serÃ¡ adicionado ao monorepo existente `aios-core`, como um novo mÃ³dulo em `.aios-core/core/graph-dashboard/` com entrypoint em `bin/aios-graph.js`.

### Service Architecture

MÃ³dulo standalone dentro do monorepo que consome dados do `code-intel` module existente e do `entity-registry`. Sem serviÃ§os externos â€” tudo local no terminal.

### Testing Requirements

Unit + Integration tests. Unit tests para cada widget/data-source adapter. Integration tests para o dashboard completo com dados mock.

### Additional Technical Assumptions and Requests

- **TUI Framework:** `blessed` (ou `neo-blessed` fork) + `blessed-contrib` â€” widgets nativos para tree, charts, sparklines, gauges
- **ASCII Charts (MVP):** `asciichart` â€” zero deps, line charts em ASCII puro para o MVP sem blessed
- **DAG Layout (V2+):** `d3-dag` â€” algoritmos Sugiyama/Zherebko para computar layout de grafos complexos
- **Node.js:** MÃ­nimo v18+ (jÃ¡ requisito do projeto)
- **Fallback Strategy:** Se `blessed` se tornar unmaintained, migrar para `neo-blessed` fork ou `Ink` (React-based TUI)
- **Data Sources:** Reutilizar 100% dos dados jÃ¡ disponÃ­veis no code-intel module (analyzeDependencies, assessImpact, getMetrics, isCodeIntelAvailable) e entity-registry.yaml

---

## Epic List

### Epic 1: MVP â€” ASCII Text Output (`aios graph`)

**Goal:** Entregar visualizaÃ§Ã£o bÃ¡sica do dependency graph e entity stats como output ASCII no terminal, sem dependÃªncias TUI pesadas.

### Epic 2: Interactive TUI Dashboard (blessed-contrib)

**Goal:** Dashboard interativo multi-painel com tree widget, charts, sparklines e gauges usando blessed-contrib.

### Epic 3: Real-time & Advanced Visualization

**Goal:** Modo watch para updates em tempo real, blast radius visual, latency charts, e mÃºltiplos formatos de output (DOT, Mermaid).

---

## Epic 1: MVP â€” ASCII Text Output

**Goal:** Estabelecer o CLI command `aios graph` com output ASCII do dependency graph e entity stats. Entrega valor imediato com zero dependÃªncias TUI pesadas â€” apenas `asciichart` para line charts simples. Este Ã© o fundamento sobre o qual os epics seguintes construirÃ£o.

### Story 1.1: CLI Entrypoint e Dependency Tree ASCII

**As a** developer using AIOS,
**I want** to run `aios graph --deps` in the terminal,
**so that** I can see the dependency tree of code-intel entities as ASCII text.

#### Acceptance Criteria

1. Comando `npx aios-core graph` existe e Ã© executÃ¡vel
2. Flag `--deps` renderiza dependency tree como texto indentado com box-drawing characters (`â”œâ”€`, `â””â”€`, `â”‚`)
3. Dados vÃªm de `analyzeDependencies()` do code-intel module
4. Fallback para entity-registry.yaml quando Code Graph MCP estÃ¡ offline
5. Output Ã© vÃ¡lido para pipe (`aios graph --deps | grep helper`)
6. Testes unitÃ¡rios cobrem: tree rendering, fallback data, empty graph

### Story 1.2: Entity Stats e Cache Metrics ASCII

**As a** developer using AIOS,
**I want** to run `aios graph --stats` to see entity statistics and cache metrics,
**so that** I can monitor the health of the code intelligence system.

#### Acceptance Criteria

1. Flag `--stats` exibe tabela formatada com: total entidades, categorias, Ãºltima atualizaÃ§Ã£o
2. Inclui cache hit/miss ratio como percentagem e ASCII sparkline (via `asciichart`)
3. Inclui latency Ãºltimas N operaÃ§Ãµes como ASCII line chart
4. Dados vÃªm de `registry-loader` + `client.getMetrics()` + `client._latencyLog`
5. Funciona sem Code Graph MCP (usa entity-registry.yaml como fallback)
6. Testes unitÃ¡rios cobrem: stats formatting, sparkline rendering, missing data handling

### Story 1.3: Provider Status e Output Formats

**As a** developer using AIOS,
**I want** to see provider status and export graph data in different formats,
**so that** I can integrate with other tools and monitor system health.

#### Acceptance Criteria

1. Sem flags adicionais, `aios graph` mostra summary view (dependency tree + stats + provider status)
2. Provider status mostra: Code Graph MCP (ACTIVE/OFFLINE), Circuit Breaker state, failure count
3. Flag `--format=json` output JSON estruturado do dependency graph
4. Flag `--format=dot` output formato DOT para Graphviz
5. Flag `--format=mermaid` output formato Mermaid para documentaÃ§Ã£o
6. Testes unitÃ¡rios cobrem: cada formato de output, provider status rendering

---

## Epic 2: Interactive TUI Dashboard (blessed-contrib)

**Goal:** Construir dashboard interativo multi-painel usando `blessed-contrib` que combina tree widget (dependency graph), charts (latency, cache), e status indicators num Ãºnico ecrÃ£ terminal. NavegaÃ§Ã£o por teclado e mouse.

### Story 2.1: Dashboard Layout e Dependency Tree Widget

**As a** developer using AIOS,
**I want** an interactive dashboard with a dependency tree I can expand/collapse,
**so that** I can explore code relationships visually in the terminal.

#### Acceptance Criteria

1. `aios graph --interactive` abre dashboard blessed-contrib fullscreen
2. Grid layout com Ã¡reas definidas: tree (esquerda), stats (direita-topo), charts (direita-baixo)
3. Tree widget renderiza dependency graph com expand/collapse via Enter
4. NavegaÃ§Ã£o por teclado (arrows, Enter, q para sair)
5. Screen resize Ã© responsivo (adapta layout)
6. Testes unitÃ¡rios cobrem: layout rendering, tree data transformation, keyboard events

### Story 2.2: MÃ©tricas e Status Widgets

**As a** developer using AIOS,
**I want** to see cache metrics, latency charts and provider status in the dashboard,
**so that** I have a complete view of the code intelligence system health.

#### Acceptance Criteria

1. Sparkline widget mostra cache hit rate em tempo real
2. Line chart widget mostra latency das Ãºltimas N operaÃ§Ãµes
3. Status widget mostra provider status (ACTIVE/OFFLINE) com cor (verde/vermelho)
4. Gauge widget mostra blast radius quando um nÃ³ Ã© selecionado no tree
5. Todos os widgets atualizam ao navegar no tree (selecionar entity â†’ atualiza blast radius)
6. Testes unitÃ¡rios cobrem: widget data binding, update cycle, error states

### Story 2.3: Data Source Adapters

**As a** developer using AIOS,
**I want** reliable data adapters that transform code-intel data for dashboard widgets,
**so that** the dashboard always shows accurate and up-to-date information.

#### Acceptance Criteria

1. `code-intel-source.js` adapter transforma output de analyzeDependencies â†’ tree widget format
2. `registry-source.js` adapter transforma entity-registry.yaml â†’ table/stats format
3. Adapters implementam caching local (5s TTL) para evitar queries repetidas
4. Adapters degradam graciosamente quando provider offline (mostram dados cached ou estÃ¡ticos)
5. Adapters expÃµem interface uniforme: `getData()`, `getLastUpdate()`, `isStale()`
6. Testes unitÃ¡rios cobrem: data transformation, caching, graceful degradation, stale detection

---

## Epic 3: Real-time & Advanced Visualization

**Goal:** Adicionar modo watch para updates automÃ¡ticos, blast radius interativo para qualquer arquivo, e comandos de agente (`*graph`) para integraÃ§Ã£o no workflow dos agentes AIOS.

### Story 3.1: Watch Mode e Auto-refresh

**As a** developer using AIOS,
**I want** the dashboard to auto-refresh every N seconds,
**so that** I can monitor the system in real-time while developing.

#### Acceptance Criteria

1. Flag `--watch` ativa auto-refresh a cada 5 segundos (configurÃ¡vel via `--interval`)
2. Apenas widgets com dados alterados sÃ£o re-renderizados (diff-based update)
3. Status bar mostra countdown para prÃ³ximo refresh
4. `Ctrl+R` forÃ§a refresh manual imediato
5. `Ctrl+C` ou `q` para sair cleanly
6. Testes unitÃ¡rios cobrem: refresh cycle, diff detection, graceful shutdown

### Story 3.2: Blast Radius Interativo

**As a** developer using AIOS,
**I want** to select any file and see its blast radius visually,
**so that** I can understand the impact of changes before making them.

#### Acceptance Criteria

1. `aios graph --blast &lt;file&gt;` mostra blast radius de um arquivo especÃ­fico
2. No dashboard interativo, selecionar nÃ³ no tree mostra blast radius no painel direito
3. Blast radius inclui: direct consumers, indirect affected, risk level (gauge)
4. Risk levels: LOW (0-3 affected), MEDIUM (4-8), HIGH (9+) com cores
5. Dados vÃªm de `assessImpact()` do code-intel enricher
6. Testes unitÃ¡rios cobrem: blast radius calculation display, risk levels, file not found handling

### Story 3.3: Agent Commands Integration

**As a** developer using AIOS,
**I want** to use graph commands within agent sessions,
**so that** I can visualize code relationships without leaving my current workflow.

#### Acceptance Criteria

1. `*graph deps` no contexto de qualquer agente mostra dependency tree ASCII inline
2. `*graph blast &lt;file&gt;` mostra blast radius inline
3. `*graph stats` mostra entity stats inline
4. Output Ã© formatado para contexto de chat (sem TUI, apenas texto formatado)
5. Comandos delegam para o mÃ³dulo graph-dashboard internamente
6. Testes unitÃ¡rios cobrem: command parsing, inline rendering, agent context integration

---

## Checklist Results Report

> PRD gerado em YOLO mode baseado em deep research completo (`docs/research/2026-02-21-cli-graph-dashboard/`). Research cobriu 5 sub-queries com 16+ sources analisadas.

**ValidaÃ§Ãµes aplicadas:**
- [x] Goals claros e alinhados com Constitution (CLI First)
- [x] Requirements rastreÃ¡veis (FR1-FR10, NFR1-NFR6)
- [x] Epics sequenciais (MVP â†’ Interactive â†’ Advanced)
- [x] Stories com acceptance criteria testÃ¡veis
- [x] Technical assumptions documentadas com rationale
- [x] DependÃªncias de dados mapeadas (code-intel module existente)
- [x] Riscos documentados no research (blessed maintenance, Windows compatibility, MCP offline)

---

## Next Steps

### UX Expert Prompt

> N/A â€” Este Ã© um CLI-only product (terminal TUI). NÃ£o hÃ¡ UI web. O design visual Ã© definido pelo blessed-contrib grid layout documentado no research (`docs/research/2026-02-21-cli-graph-dashboard/03-recommendations.md`).

### Architect Prompt

> @architect â€” Crie a arquitetura tÃ©cnica detalhada para o CLI Graph Dashboard usando este PRD como input. Foco em: (1) estrutura de mÃ³dulos dentro de `.aios-core/core/graph-dashboard/`, (2) data source adapters para code-intel e entity-registry, (3) widget composition pattern com blessed-contrib, (4) CLI command routing via `bin/aios-graph.js`, (5) fallback strategy quando Code Graph MCP estÃ¡ offline. Reference: `docs/research/2026-02-21-cli-graph-dashboard/03-recommendations.md` para stack recomendado.

---

*â€” Morgan, planejando o futuro ğŸ“Š*
